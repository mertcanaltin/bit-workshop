{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useApolloClient.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useLazyQuery.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useQuery.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/parser/index.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/useDeepMemo.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/useIsomorphicLayoutEffect.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/useRenderGuard.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/useLazyRef.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/__use.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/wrapHook.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useMutation.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useSubscription.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useReactiveVar.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useFragment.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useSuspenseQuery.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/internal/cache/QueryReference.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/internal/cache/SuspenseCache.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/internal/cache/getSuspenseCache.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/constants.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useBackgroundQuery.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useLoadableQuery.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useQueryRefHandlers.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useReadQuery.ts", "../../../../../node_modules/.pnpm/@apollo+client@3.9.9_@types+react@18.2.23_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/query-preloader/createQueryPreloader.ts"],
  "sourcesContent": ["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\n\n/**\n * @example\n * ```jsx\n * import { useApolloClient } from '@apollo/client';\n *\n * function SomeComponent() {\n *   const client = useApolloClient();\n *   // `client` is now set to the `ApolloClient` instance being used by the\n *   // application (that was configured using something like `ApolloProvider`)\n * }\n * ```\n *\n * @since 3.0.0\n * @returns The `ApolloClient` instance being used by the application.\n */\nexport function useApolloClient(\n  override?: ApolloClient<object>\n): ApolloClient<object> {\n  const context = React.useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n      \"Wrap the root component in an <ApolloProvider>, or pass an ApolloClient \" +\n      \"instance in via options.\"\n  );\n\n  return client;\n}\n", "import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"rehackt\";\n\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryResult,\n} from \"../types/types.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLazyQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(\n *     GET_GREETING,\n *     { variables: { language: \"english\" } }\n *   );\n *   if (called && loading) return <p>Loading ...</p>\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = options;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current,\n  });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdateState();\n        }\n        // @ts-expect-error this is just too generic to type\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current =\n        executeOptions ?\n          {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = internalState\n        .executeQuery({ ...options, skip: false })\n        .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    []\n  );\n\n  return [execute, result];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type { ApolloContextValue } from \"../context/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  canUseWeakMap,\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return wrapHook(\n    \"useQuery\",\n    _useQuery,\n    useApolloClient(options && options.client)\n  )(query, options);\n}\n\nfunction _useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  return useInternalState(useApolloClient(options.client), query).useQuery(\n    options\n  );\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>\n): InternalState<TData, TVariables> {\n  const stateRef = React.useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  state.forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  forceUpdateState() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\n      \"Calling default no-op implementation of InternalState#forceUpdate\"\n    );\n  }\n\n  /**\n   * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n   * whenever it is available and reset to `forceUpdateState` when it isn't.\n   */\n  forceUpdate = () => this.forceUpdateState();\n\n  executeQuery(\n    options: QueryHookOptions<TData, TVariables> & {\n      query?: DocumentNode;\n    }\n  ) {\n    if (options.query) {\n      Object.assign(this, { query: options.query });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        },\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      React.useCallback(\n        (handleStoreChange) => {\n          if (this.renderPromises) {\n            return () => {};\n          }\n\n          this.forceUpdate = handleStoreChange;\n\n          const onNext = () => {\n            const previousResult = this.result;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            const result = obsQuery.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (\n              previousResult &&\n              previousResult.loading === result.loading &&\n              previousResult.networkStatus === result.networkStatus &&\n              equal(previousResult.data, result.data)\n            ) {\n              return;\n            }\n\n            this.setResult(result);\n          };\n\n          const onError = (error: Error) => {\n            subscription.unsubscribe();\n            subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n              // The error is not a GraphQL error\n              throw error;\n            }\n\n            const previousResult = this.result;\n            if (\n              !previousResult ||\n              (previousResult && previousResult.loading) ||\n              !equal(error, previousResult.error)\n            ) {\n              this.setResult({\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              });\n            }\n          };\n\n          let subscription = obsQuery.subscribe(onNext, onError);\n\n          // Do the \"unsubscribe\" with a short delay.\n          // This way, an existing subscription can be reused without an additional\n          // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n          // happen in very fast succession.\n          return () => {\n            setTimeout(() => subscription.unsubscribe());\n            this.forceUpdate = () => this.forceUpdateState();\n          };\n        },\n        [\n          // We memoize the subscribe function using useCallback and the following\n          // dependency keys, because the subscribe function reference is all that\n          // useSyncExternalStore uses internally as a dependency key for the\n          // useEffect ultimately responsible for the subscription, so we are\n          // effectively passing this dependency array to that useEffect buried\n          // inside useSyncExternalStore, as desired.\n          obsQuery,\n          this.renderPromises,\n          this.client.disableNetworkFetches,\n        ]\n      ),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult()\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions!: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions!: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(options: QueryHookOptions<TData, TVariables>) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted =\n      options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === \"standby\"\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(\n      compact(\n        this.observable && this.observable.options,\n        this.watchQueryOptions\n      )\n    );\n\n    return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<\n    TVariables,\n    TData\n  > {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: \"standby\",\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable!: ObservableQuery<TData, TVariables>;\n  private obsQueryFields!: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = (this.observable =\n      (this.renderPromises &&\n        this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n      this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions()));\n\n    this.obsQueryFields = React.useMemo(\n      () => ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n      }),\n      [obsQuery]\n    );\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false || this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  }\n\n  private handleErrorOrCompleted(\n    result: ApolloQueryResult<TData>,\n    previousResult?: ApolloQueryResult<TData>\n  ) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve()\n        .then(() => {\n          if (error) {\n            this.onError(error);\n          } else if (\n            result.data &&\n            previousResult?.networkStatus !== result.networkStatus &&\n            result.networkStatus === NetworkStatus.ready\n          ) {\n            this.onCompleted(result.data);\n          }\n        })\n        .catch((error) => {\n          invariant.warn(error);\n        });\n    }\n  }\n\n  private toApolloError(\n    result: ApolloQueryResult<TData>\n  ): ApolloError | undefined {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n      : result.error;\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        (this.result = this.observable.getCurrentResult())\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(\n      result,\n      (queryResult = {\n        data, // Ensure always defined, even if result.data is missing.\n        ...resultWithoutPartial,\n        ...this.obsQueryFields,\n        client: this.client,\n        observable: this.observable,\n        variables: this.observable.variables,\n        called: !this.queryHookOptions.skip,\n        previousData: this.previousData,\n      })\n    );\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== \"cache-only\"\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\n\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n} from \"graphql\";\nimport {\n  AutoCleanedWeakCache,\n  cacheSizes,\n  defaultCacheSizes,\n} from \"../../utilities/index.js\";\nimport { registerGlobalCache } from \"../../utilities/caching/getMemoryInternals.js\";\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription,\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nlet cache:\n  | undefined\n  | AutoCleanedWeakCache<\n      DocumentNode,\n      {\n        name: string;\n        type: DocumentType;\n        variables: readonly VariableDefinitionNode[];\n      }\n    >;\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = \"Query\";\n      break;\n    case DocumentType.Mutation:\n      name = \"Mutation\";\n      break;\n    case DocumentType.Subscription:\n      name = \"Subscription\";\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  if (!cache) {\n    cache = new AutoCleanedWeakCache(\n      cacheSizes.parser || defaultCacheSizes.parser\n    );\n  }\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of %s passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`,\n    document\n  );\n\n  const fragments: DefinitionNode[] = [];\n  const queries: DefinitionNode[] = [];\n  const mutations: DefinitionNode[] = [];\n  const subscriptions: DefinitionNode[] = [];\n\n  for (const x of document.definitions) {\n    if (x.kind === \"FragmentDefinition\") {\n      fragments.push(x);\n      continue;\n    }\n\n    if (x.kind === \"OperationDefinition\") {\n      switch (x.operation) {\n        case \"query\":\n          queries.push(x);\n          break;\n        case \"mutation\":\n          mutations.push(x);\n          break;\n        case \"subscription\":\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      queries.length ||\n      mutations.length ||\n      subscriptions.length,\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `%s had %s queries, %s ` +\n      `subscriptions and %s mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    queries.length,\n    subscriptions.length,\n    mutations.length\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions =\n    queries.length ? queries\n    : mutations.length ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. %s had ` +\n      `%s definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    definitions.length\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === \"Name\") {\n    name = definition.name.value;\n  } else {\n    name = \"data\"; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nparser.resetCache = () => {\n  cache = undefined;\n};\n\nif (__DEV__) {\n  registerGlobalCache(\"parser\", () => (cache ? cache.size : 0));\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a %s requires a graphql ` + `%s, but a %s was used instead.`,\n    requiredOperationName,\n    requiredOperationName,\n    usedOperationName\n  );\n}\n", "import type { DependencyList } from \"react\";\nimport * as React from \"rehackt\";\nimport { equal } from \"@wry/equality\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>();\n\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    ref.current = { value: memoFn(), deps };\n  }\n\n  return ref.current.value;\n}\n", "import * as React from \"rehackt\";\nimport { canUseDOM } from \"../../../utilities/index.js\";\n\n// use canUseDOM here instead of canUseLayoutEffect because we want to be able\n// to use useLayoutEffect in our jest tests. useLayoutEffect seems to work fine\n// in useSuspenseQuery tests, but to honor the original comment about the\n// warnings for useSyncExternalStore implementation, canUseLayoutEffect is left\n// alone.\nexport const useIsomorphicLayoutEffect =\n  canUseDOM ? React.useLayoutEffect : React.useEffect;\n", "import * as React from \"rehackt\";\n\nfunction getRenderDispatcher() {\n  return (React as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n    ?.ReactCurrentDispatcher?.current;\n}\n\nlet RenderDispatcher: unknown = null;\n\n/*\nRelay does this too, so we hope this is safe.\nhttps://github.com/facebook/relay/blob/8651fbca19adbfbb79af7a3bc40834d105fd7747/packages/react-relay/relay-hooks/loadQuery.js#L90-L98\n*/\nexport function useRenderGuard() {\n  RenderDispatcher = getRenderDispatcher();\n\n  return React.useCallback(() => {\n    return (\n      RenderDispatcher != null && RenderDispatcher === getRenderDispatcher()\n    );\n  }, []);\n}\n", "import * as React from \"rehackt\";\n\nconst INIT = {};\n\nexport function useLazyRef<T>(getInitialValue: () => T) {\n  const ref = React.useRef<T>(INIT as unknown as T);\n\n  if (ref.current === INIT) {\n    ref.current = getInitialValue();\n  }\n\n  return ref;\n}\n", "import { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport * as React from \"rehackt\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n// Prevent webpack from complaining about our feature detection of the\n// use property of the React namespace, which is expected not\n// to exist when using current stable versions, and that's fine.\nconst useKey = \"use\" as keyof typeof React;\nconst realHook = React[useKey] as Use | undefined;\n\n// This is named with two underscores to allow this hook to evade typical rules of\n// hooks (i.e. it can be used conditionally)\nexport const __use =\n  realHook ||\n  function __use<TValue>(promise: Promise<TValue>) {\n    const statefulPromise = wrapPromiseWithState(promise);\n\n    switch (statefulPromise.status) {\n      case \"pending\":\n        throw statefulPromise;\n      case \"rejected\":\n        throw statefulPromise.reason;\n      case \"fulfilled\":\n        return statefulPromise.value;\n    }\n  };\n", "import type {\n  useQuery,\n  useSuspenseQuery,\n  useBackgroundQuery,\n  useReadQuery,\n  useFragment,\n} from \"../index.js\";\nimport type { QueryManager } from \"../../../core/QueryManager.js\";\nimport type { ApolloClient } from \"../../../core/ApolloClient.js\";\nimport type { ObservableQuery } from \"../../../core/ObservableQuery.js\";\n\nconst wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\n\ninterface WrappableHooks {\n  useQuery: typeof useQuery;\n  useSuspenseQuery: typeof useSuspenseQuery;\n  useBackgroundQuery: typeof useBackgroundQuery;\n  useReadQuery: typeof useReadQuery;\n  useFragment: typeof useFragment;\n}\n\n/**\n * @internal\n * Can be used to correctly type the [Symbol.for(\"apollo.hook.wrappers\")] property of\n * `QueryManager`, to override/wrap hook functionality.\n */\nexport type HookWrappers = {\n  [K in keyof WrappableHooks]?: (\n    originalHook: WrappableHooks[K]\n  ) => WrappableHooks[K];\n};\n\ninterface QueryManagerWithWrappers<T> extends QueryManager<T> {\n  [wrapperSymbol]?: HookWrappers;\n}\n\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook<Hook extends (...args: any[]) => any>(\n  hookName: keyof WrappableHooks,\n  useHook: Hook,\n  clientOrObsQuery: ObservableQuery<any> | ApolloClient<any>\n): Hook {\n  const queryManager = (\n    clientOrObsQuery as unknown as {\n      // both `ApolloClient` and `ObservableQuery` have a `queryManager` property\n      // but they're both `private`, so we have to cast around for a bit here.\n      queryManager: QueryManagerWithWrappers<any>;\n    }\n  )[\"queryManager\"];\n  const wrappers = queryManager && queryManager[wrapperSymbol];\n  const wrapper: undefined | ((wrap: Hook) => Hook) =\n    wrappers && (wrappers[hookName] as any);\n  return wrapper ? wrapper(useHook) : useHook;\n}\n", "import * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport type {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport type {\n  ApolloCache,\n  DefaultContext,\n  MutationOptions,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n/**\n *\n *\n * > Refer to the [Mutations](https://www.apollographql.com/docs/react/data/mutations/) section for a more in-depth overview of `useMutation`.\n *\n * @example\n * ```jsx\n * import { gql, useMutation } from '@apollo/client';\n *\n * const ADD_TODO = gql`\n *   mutation AddTodo($type: String!) {\n *     addTodo(type: $type) {\n *       id\n *       type\n *     }\n *   }\n * `;\n *\n * function AddTodo() {\n *   let input;\n *   const [addTodo, { data }] = useMutation(ADD_TODO);\n *\n *   return (\n *     <div>\n *       <form\n *         onSubmit={e => {\n *           e.preventDefault();\n *           addTodo({ variables: { type: input.value } });\n *           input.value = '';\n *         }}\n *       >\n *         <input\n *           ref={node => {\n *             input = node;\n *           }}\n *         />\n *         <button type=\"submit\">Add Todo</button>\n *       </form>\n *     </div>\n *   );\n * }\n * ```\n * @since 3.0.0\n * @param mutation - A GraphQL mutation document parsed into an AST by `gql`.\n * @param options - Options to control how the mutation is executed.\n * @returns A tuple in the form of `[mutate, result]`\n */\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>,\n    TContext,\n    TCache\n  >\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = React.useState<Omit<MutationResult, \"reset\">>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = React.useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = React.useCallback(\n    (\n      executeOptions: MutationFunctionOptions<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      > = {}\n    ) => {\n      const { options, mutation } = ref.current;\n      const baseOptions = { ...options, mutation };\n      const client = executeOptions.client || ref.current.client;\n\n      if (\n        !ref.current.result.loading &&\n        !baseOptions.ignoreResults &&\n        ref.current.isMounted\n      ) {\n        setResult(\n          (ref.current.result = {\n            loading: true,\n            error: void 0,\n            data: void 0,\n            called: true,\n            client,\n          })\n        );\n      }\n\n      const mutationId = ++ref.current.mutationId;\n      const clientOptions = mergeOptions(baseOptions, executeOptions);\n\n      return client\n        .mutate(clientOptions as MutationOptions<TData, OperationVariables>)\n        .then((response) => {\n          const { data, errors } = response;\n          const error =\n            errors && errors.length > 0 ?\n              new ApolloError({ graphQLErrors: errors })\n            : void 0;\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (error && onError) {\n            onError(\n              error,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n          }\n\n          if (\n            mutationId === ref.current.mutationId &&\n            !clientOptions.ignoreResults\n          ) {\n            const result = {\n              called: true,\n              loading: false,\n              data,\n              error,\n              client,\n            };\n\n            if (ref.current.isMounted && !equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onCompleted =\n            executeOptions.onCompleted || ref.current.options?.onCompleted;\n\n          if (!error) {\n            onCompleted?.(\n              response.data!,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n          }\n\n          return response;\n        })\n        .catch((error) => {\n          if (mutationId === ref.current.mutationId && ref.current.isMounted) {\n            const result = {\n              loading: false,\n              error,\n              data: void 0,\n              called: true,\n              client,\n            };\n\n            if (!equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (onError) {\n            onError(\n              error,\n              clientOptions as MutationOptions<TData, OperationVariables>\n            );\n\n            // TODO(brian): why are we returning this here???\n            return { data: void 0, errors: error };\n          }\n\n          throw error;\n        });\n    },\n    []\n  );\n\n  const reset = React.useCallback(() => {\n    if (ref.current.isMounted) {\n      const result = { called: false, loading: false, client };\n      Object.assign(ref.current, { mutationId: 0, result });\n      setResult(result);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n * @remarks\n * #### Subscriptions and React 18 Automatic Batching\n *\n * With React 18's [automatic batching](https://react.dev/blog/2022/03/29/react-v18#new-feature-automatic-batching), multiple state updates may be grouped into a single re-render for better performance.\n *\n * If your subscription API sends multiple messages at the same time or in very fast succession (within fractions of a millisecond), it is likely that only the last message received in that narrow time frame will result in a re-render.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * If your subscription back-end emits two messages with the same timestamp, only the last message received by Apollo Client will be rendered. This is because React 18 will batch these two state updates into a single re-render.\n *\n * Since the component above is using `useEffect` to push `data` into a piece of local state on each `Subscriptions` re-render, the first message will never be added to the `accumulatedData` array since its render was skipped.\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(\n *     query,\n *     {\n *       onData({ data }) {\n *         setAccumulatedData((prev) => [...prev, data])\n *       }\n *     }\n *   );\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * > ⚠️ **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @since 3.0.0\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = React.useState<\n    SubscriptionResult<TData, TVariables>\n  >({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options?.onSubscriptionData) {\n      invariant.warn(\n        options.onData ?\n          \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n        : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options?.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete ?\n          \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n        : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const [observable, setObservable] = React.useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = React.useRef(false);\n  React.useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = React.useRef({ client, subscription, options });\n  React.useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (\n        !options?.skip !== !ref.current.options?.skip ||\n        canResetObservableRef.current\n      ) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(\n        client.subscribe({\n          query: subscription,\n          variables: options?.variables,\n          fetchPolicy: options?.fetchPolicy,\n          context: options?.context,\n        })\n      );\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  React.useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    let subscriptionStopped = false;\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        if (subscriptionStopped) {\n          return;\n        }\n\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        if (ref.current.options?.onData) {\n          ref.current.options.onData({\n            client,\n            data: result,\n          });\n        } else if (ref.current.options?.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client,\n            subscriptionData: result,\n          });\n        }\n      },\n      error(error) {\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error,\n            variables: options?.variables,\n          });\n          ref.current.options?.onError?.(error);\n        }\n      },\n      complete() {\n        if (!subscriptionStopped) {\n          if (ref.current.options?.onComplete) {\n            ref.current.options.onComplete();\n          } else if (ref.current.options?.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      },\n    });\n\n    return () => {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(() => {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n\n  return result;\n}\n", "import * as React from \"rehackt\";\nimport type { ReactiveVar } from \"../../core/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\n/**\n * Reads the value of a [reactive variable](https://www.apollographql.com/docs/react/local-state/reactive-variables/) and re-renders the containing component whenever that variable's value changes. This enables a reactive variable to trigger changes _without_ relying on the `useQuery` hook.\n *\n * @example\n * ```jsx\n * import { makeVar, useReactiveVar } from \"@apollo/client\";\n * export const cartItemsVar = makeVar([]);\n *\n * export function Cart() {\n *   const cartItems = useReactiveVar(cartItemsVar);\n *   // ...\n * }\n * ```\n * @since 3.2.0\n * @param rv - A reactive variable.\n * @returns The current value of the reactive variable.\n */\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  return useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        // By reusing the same onNext function in the nested call to\n        // rv.onNextChange(onNext), we can keep using the initial clean-up function\n        // returned by rv.onNextChange(function onNext(v){...}), without having to\n        // register the new clean-up function (returned by the nested\n        // rv.onNextChange(onNext)) with yet another callback.\n        return rv.onNextChange(function onNext() {\n          update();\n          rv.onNextChange(onNext);\n        });\n      },\n      [rv]\n    ),\n    rv,\n    rv\n  );\n}\n", "import * as React from \"rehackt\";\nimport { equal } from \"@wry/equality\";\n\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport type {\n  Cache,\n  Reference,\n  StoreObject,\n  MissingTree,\n} from \"../../cache/index.js\";\n\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { ApolloClient, OperationVariables } from \"../../core/index.js\";\nimport type { NoInfer } from \"../types/types.js\";\nimport { useDeepMemo, useLazyRef, wrapHook } from \"./internal/index.js\";\n\nexport interface UseFragmentOptions<TData, TVars>\n  extends Omit<\n      Cache.DiffOptions<NoInfer<TData>, NoInfer<TVars>>,\n      \"id\" | \"query\" | \"optimistic\" | \"previousResult\" | \"returnPartialData\"\n    >,\n    Omit<\n      Cache.ReadFragmentOptions<TData, TVars>,\n      \"id\" | \"variables\" | \"returnPartialData\"\n    > {\n  from: StoreObject | Reference | string;\n  // Override this field to make it optional (default: true).\n  optimistic?: boolean;\n  /**\n   * The instance of `ApolloClient` to use to look up the fragment.\n   *\n   * By default, the instance that's passed down via context is used, but you\n   * can provide a different instance here.\n   *\n   * @docGroup 1. Operation options\n   */\n  client?: ApolloClient<any>;\n}\n\nexport type UseFragmentResult<TData> =\n  | {\n      data: TData;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<TData>;\n      complete: false;\n      missing?: MissingTree;\n    };\n\nexport function useFragment<TData = any, TVars = OperationVariables>(\n  options: UseFragmentOptions<TData, TVars>\n): UseFragmentResult<TData> {\n  return wrapHook(\n    \"useFragment\",\n    _useFragment,\n    useApolloClient(options.client)\n  )(options);\n}\n\nfunction _useFragment<TData = any, TVars = OperationVariables>(\n  options: UseFragmentOptions<TData, TVars>\n): UseFragmentResult<TData> {\n  const { cache } = useApolloClient(options.client);\n\n  const diffOptions = useDeepMemo<Cache.DiffOptions<TData, TVars>>(() => {\n    const {\n      fragment,\n      fragmentName,\n      from,\n      optimistic = true,\n      ...rest\n    } = options;\n\n    return {\n      ...rest,\n      returnPartialData: true,\n      id: typeof from === \"string\" ? from : cache.identify(from),\n      query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n      optimistic,\n    };\n  }, [options]);\n\n  const resultRef = useLazyRef<UseFragmentResult<TData>>(() =>\n    diffToResult(cache.diff<TData>(diffOptions))\n  );\n\n  // Since .next is async, we need to make sure that we\n  // get the correct diff on the next render given new diffOptions\n  React.useMemo(() => {\n    resultRef.current = diffToResult(cache.diff<TData>(diffOptions));\n  }, [diffOptions, cache]);\n\n  // Used for both getSnapshot and getServerSnapshot\n  const getSnapshot = React.useCallback(() => resultRef.current, []);\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        let lastTimeout = 0;\n        const unsubscribe = cache.watch({\n          ...diffOptions,\n          immediate: true,\n          callback(diff) {\n            if (!equal(diff.result, resultRef.current.data)) {\n              resultRef.current = diffToResult(diff);\n              // If we get another update before we've re-rendered, bail out of\n              // the update and try again. This ensures that the relative timing\n              // between useQuery and useFragment stays roughly the same as\n              // fixed in https://github.com/apollographql/apollo-client/pull/11083\n              clearTimeout(lastTimeout);\n              lastTimeout = setTimeout(forceUpdate) as any;\n            }\n          },\n        });\n        return () => {\n          unsubscribe();\n          clearTimeout(lastTimeout);\n        };\n      },\n      [cache, diffOptions]\n    ),\n    getSnapshot,\n    getSnapshot\n  );\n}\n\nfunction diffToResult<TData>(\n  diff: Cache.DiffResult<TData>\n): UseFragmentResult<TData> {\n  const result = {\n    data: diff.result!,\n    complete: !!diff.complete,\n  } as UseFragmentResult<TData>;\n\n  if (diff.missing) {\n    result.missing = mergeDeepArray(diff.missing.map((error) => error.missing));\n  }\n\n  return result;\n}\n", "import * as React from \"rehackt\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../internal/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey, QueryKey } from \"../internal/index.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: TData;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: TData,\n      options: {\n        fetchMoreResult: TData;\n        variables: TVariables;\n      }\n    ) => TData;\n  }\n) => Promise<ApolloQueryResult<TData>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ?\n    TOptions[\"skip\"] extends boolean ?\n      DeepPartial<TData> | undefined\n    : DeepPartial<TData>\n  : TOptions[\"skip\"] extends boolean ? TData | undefined\n  : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  return wrapHook(\n    \"useSuspenseQuery\",\n    _useSuspenseQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables>\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  let [current, setPromise] = React.useState<\n    [QueryKey, Promise<ApolloQueryResult<any>>]\n  >([queryRef.key, queryRef.promise]);\n\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  let promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromise([queryRef.key, promise]);\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n  const fetchMore = React.useCallback(\n    ((options) => {\n      const promise = queryRef.fetchMore(options);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    }) satisfies FetchMoreFunction<\n      unknown,\n      OperationVariables\n    > as FetchMoreFunction<TData | undefined, TVariables>,\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore: SubscribeToMoreFunction<\n    TData | undefined,\n    TVariables\n  > = React.useCallback(\n    (options) => queryRef.observable.subscribeToMore(options),\n    [queryRef]\n  );\n\n  return React.useMemo<\n    UseSuspenseQueryResult<TData | undefined, TVariables>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors) ?\n      new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n", "import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../../core/index.js\";\nimport type {\n  ObservableSubscription,\n  PromiseWithState,\n} from \"../../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../../utilities/index.js\";\nimport type { QueryKey } from \"./types.js\";\nimport { wrapPromiseWithState } from \"../../../utilities/index.js\";\n\ntype QueryRefPromise<TData> = PromiseWithState<ApolloQueryResult<TData>>;\n\ntype Listener<TData> = (promise: QueryRefPromise<TData>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\nconst PROMISE_SYMBOL: unique symbol = Symbol();\n\n/**\n * A `QueryReference` is an opaque object returned by `useBackgroundQuery`.\n * A child component reading the `QueryReference` via `useReadQuery` will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown, TVariables = unknown> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData>;\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return queryRef.toPromise();\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   *\n   * @alpha\n   */\n  toPromise(): Promise<QueryReference<TData, TVariables>>;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData, TVariables extends OperationVariables>(\n  internalQueryRef: InternalQueryReference<TData>\n) {\n  const ref: QueryReference<TData, TVariables> = {\n    toPromise() {\n      // We avoid resolving this promise with the query data because we want to\n      // discourage using the server data directly from the queryRef. Instead,\n      // the data should be accessed through `useReadQuery`. When the server\n      // data is needed, its better to use `client.query()` directly.\n      //\n      // Here we resolve with the ref itself to make using this in React Router\n      // or TanStack Router `loader` functions a bit more ergonomic e.g.\n      //\n      // function loader() {\n      //   return { queryRef: await preloadQuery(query).toPromise() }\n      // }\n      return getWrappedPromise(ref).then(() => ref);\n    },\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  };\n\n  return ref;\n}\n\nexport function getWrappedPromise<TData>(queryRef: QueryReference<TData, any>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<TData>(\n  queryRef: QueryReference<TData>,\n  promise: QueryRefPromise<TData>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result!: ApolloQueryResult<TData>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData>;\n\n  private subscription!: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n  private softReferences = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n\n    try {\n      if (originalFetchPolicy !== \"no-cache\") {\n        observable.resetLastResults();\n        observable.silentSetOptions({ fetchPolicy: \"cache-first\" });\n      } else {\n        observable.silentSetOptions({ fetchPolicy: \"standby\" });\n      }\n\n      this.subscribeToQuery();\n\n      if (originalFetchPolicy === \"no-cache\") {\n        return;\n      }\n\n      observable.resetDiff();\n      this.setResult();\n    } finally {\n      observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        option in watchQueryOptions &&\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.promise.status) {\n      case \"pending\": {\n        this.reject?.(error);\n        break;\n      }\n      default: {\n        this.promise = createRejectedPromise<ApolloQueryResult<TData>>(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then(() => {\n        // In the case of `fetchMore`, this promise is resolved before a cache\n        // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n        // fetch policy and runs `cache.batch` in its `.then` handler. Because\n        // the timing is different, we accidentally run this update twice\n        // causing an additional re-render with the `fetchMore` result by\n        // itself. By wrapping in `setTimeout`, this should provide a short\n        // delay to allow the `QueryInfo.notify` handler to run before this\n        // promise is checked.\n        // See https://github.com/apollographql/apollo-client/issues/11315 for\n        // more information\n        setTimeout(() => {\n          if (this.promise.status === \"pending\") {\n            // Use the current result from the observable instead of the value\n            // resolved from the promise. This avoids issues in some cases where\n            // the raw resolved value should not be the emitted value, such as\n            // when a `fetchMore` call returns an empty array after it has\n            // reached the end of the list.\n            //\n            // See the following for more information:\n            // https://github.com/apollographql/apollo-client/issues/11642\n            this.result = this.observable.getCurrentResult();\n            this.resolve?.(this.result);\n          }\n        });\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .filter(\n        (result) => !equal(result.data, {}) && !equal(result, this.result)\n      )\n      .subscribe(this.handleNext, this.handleError);\n  }\n\n  private setResult() {\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    const result = this.observable.getCurrentResult(false);\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      (\n        result.data &&\n        (!result.partial || this.watchQueryOptions.returnPartialData)\n      ) ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private createPendingPromise() {\n    return wrapPromiseWithState(\n      new Promise<ApolloQueryResult<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n}\n", "import { Trie } from \"@wry/trie\";\nimport type { ObservableQuery } from \"../../../core/index.js\";\nimport { canUseWeakMap } from \"../../../utilities/index.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>(\n    canUseWeakMap\n  );\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = Object.create(null)) {\n    this.options = options;\n  }\n\n  getQueryRef<TData = any>(\n    cacheKey: CacheKey,\n    createObservable: () => ObservableQuery<TData>\n  ) {\n    const ref = this.queryRefs.lookupArray(cacheKey) as {\n      current?: InternalQueryReference<TData>;\n    };\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n}\n", "import type { SuspenseCacheOptions } from \"../index.js\";\nimport { SuspenseCache } from \"./SuspenseCache.js\";\nimport type { ApolloClient } from \"../../../core/ApolloClient.js\";\n\ndeclare module \"../../../core/ApolloClient.js\" {\n  interface DefaultOptions {\n    react?: {\n      suspense?: Readonly<SuspenseCacheOptions>;\n    };\n  }\n}\n\nconst suspenseCacheSymbol = Symbol.for(\"apollo.suspenseCache\");\n\nexport function getSuspenseCache(\n  client: ApolloClient<object> & {\n    [suspenseCacheSymbol]?: SuspenseCache;\n  }\n) {\n  if (!client[suspenseCacheSymbol]) {\n    client[suspenseCacheSymbol] = new SuspenseCache(\n      client.defaultOptions.react?.suspense\n    );\n  }\n\n  return client[suspenseCacheSymbol];\n}\n", "export const skipToken = Symbol.for(\"apollo.skipToken\");\nexport type SkipToken = typeof skipToken;\n", "import * as React from \"rehackt\";\nimport type {\n  DocumentNode,\n  FetchMoreQueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { CacheKey, QueryReference } from \"../internal/index.js\";\nimport type { BackgroundQueryHookOptions, NoInfer } from \"../types/types.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreFunction, RefetchFunction } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport type { SkipToken } from \"./constants.js\";\n\nexport type UseBackgroundQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  refetch: RefetchFunction<TData, TVariables>;\n};\n\ntype BackgroundQueryHookOptionsNoInfer<\n  TData,\n  TVariables extends OperationVariables,\n> = BackgroundQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>;\n\nexport function useBackgroundQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<BackgroundQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & TOptions\n): [\n  (\n    | QueryReference<\n        TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n          TOptions[\"returnPartialData\"] extends true ?\n            DeepPartial<TData> | undefined\n          : TData | undefined\n        : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n        : TData,\n        TVariables\n      >\n    | (TOptions[\"skip\"] extends boolean ? undefined : never)\n  ),\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<DeepPartial<TData> | undefined, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<TData | undefined, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n  }\n): [\n  QueryReference<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryReference<TData, TVariables>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n        returnPartialData: true;\n      })\n): [\n  QueryReference<DeepPartial<TData>, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryReference<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables> = Object.create(null)\n): [\n  QueryReference<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  return wrapHook(\n    \"useBackgroundQuery\",\n    _useBackgroundQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryReference<TData, TVariables> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions as WatchQueryOptions<any, any>)\n  );\n\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(\n    wrapQueryRef(queryRef)\n  );\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options as FetchMoreQueryOptions<any>);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  React.useEffect(() => queryRef.softRetain(), [queryRef]);\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    { fetchMore, refetch },\n  ];\n}\n", "import * as React from \"rehackt\";\nimport type {\n  DocumentNode,\n  FetchMoreQueryOptions,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { CacheKey, QueryReference } from \"../internal/index.js\";\nimport type { LoadableQueryHookOptions } from \"../types/types.js\";\nimport { __use, useRenderGuard } from \"./internal/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreFunction, RefetchFunction } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type {\n  DeepPartial,\n  OnlyRequiredProperties,\n} from \"../../utilities/index.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n\nexport type LoadQueryFunction<TVariables extends OperationVariables> = (\n  // Use variadic args to handle cases where TVariables is type `never`, in\n  // which case we don't want to allow a variables argument. In other\n  // words, we don't want to allow variables to be passed as an argument to this\n  // function if the query does not expect variables in the document.\n  ...args: [TVariables] extends [never] ? []\n  : {} extends OnlyRequiredProperties<TVariables> ? [variables?: TVariables]\n  : [variables: TVariables]\n) => void;\n\ntype ResetFunction = () => void;\n\nexport type UseLoadableQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = [\n  loadQuery: LoadQueryFunction<TVariables>,\n  queryRef: QueryReference<TData, TVariables> | null,\n  {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n    refetch: RefetchFunction<TData, TVariables>;\n    /**\n     * A function that resets the `queryRef` back to `null`.\n     */\n    reset: ResetFunction;\n  },\n];\n\nexport function useLoadableQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends LoadableQueryHookOptions,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LoadableQueryHookOptions & TOptions\n): UseLoadableQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n  : TData,\n  TVariables\n>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseLoadableQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseLoadableQueryResult<TData | undefined, TVariables>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions & {\n    returnPartialData: true;\n  }\n): UseLoadableQueryResult<DeepPartial<TData>, TVariables>;\n\n/**\n * A hook for imperatively loading a query, such as responding to a user\n * interaction.\n *\n * > Refer to the [Suspense - Fetching in response to user interaction](https://www.apollographql.com/docs/react/data/suspense#fetching-in-response-to-user-interaction) section for a more in-depth overview of `useLoadableQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useLoadableQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function App() {\n *   const [loadGreeting, queryRef] = useLoadableQuery(GET_GREETING);\n *\n *   return (\n *     <>\n *       <button onClick={() => loadGreeting({ language: \"english\" })}>\n *         Load greeting\n *       </button>\n *       <Suspense fallback={<div>Loading...</div>}>\n *         {queryRef && <Hello queryRef={queryRef} />}\n *       </Suspense>\n *     </>\n *   );\n * }\n *\n * function Hello({ queryRef }) {\n *   const { data } = useReadQuery(queryRef);\n *\n *   return <div>{data.greeting.message}</div>;\n * }\n * ```\n *\n * @since 3.9.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns A tuple in the form of `[loadQuery, queryRef, handlers]`\n */\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LoadableQueryHookOptions\n): UseLoadableQueryResult<TData, TVariables>;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: LoadableQueryHookOptions = Object.create(null)\n): UseLoadableQueryResult<TData, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { queryKey = [] } = options;\n\n  const [queryRef, setQueryRef] = React.useState<QueryReference<\n    TData,\n    TVariables\n  > | null>(null);\n\n  const internalQueryRef = queryRef && unwrapQueryRef(queryRef);\n\n  if (queryRef && internalQueryRef?.didChangeOptions(watchQueryOptions)) {\n    const promise = internalQueryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(queryRef, promise);\n  }\n\n  const calledDuringRender = useRenderGuard();\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      if (!internalQueryRef) {\n        throw new Error(\n          \"The query has not been loaded. Please load the query.\"\n        );\n      }\n\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<TVariables, TData>\n      );\n\n      setQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      if (!internalQueryRef) {\n        throw new Error(\n          \"The query has not been loaded. Please load the query.\"\n        );\n      }\n\n      const promise = internalQueryRef.refetch(options);\n\n      setQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const loadQuery: LoadQueryFunction<TVariables> = React.useCallback(\n    (...args) => {\n      invariant(\n        !calledDuringRender(),\n        \"useLoadableQuery: 'loadQuery' should not be called during render. To start a query during render, use the 'useBackgroundQuery' hook.\"\n      );\n\n      const [variables] = args;\n\n      const cacheKey: CacheKey = [\n        query,\n        canonicalStringify(variables),\n        ...([] as any[]).concat(queryKey),\n      ];\n\n      const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n        client.watchQuery({\n          ...watchQueryOptions,\n          variables,\n        } as WatchQueryOptions<any, any>)\n      );\n\n      setQueryRef(wrapQueryRef(queryRef));\n    },\n    [query, queryKey, suspenseCache, watchQueryOptions, calledDuringRender]\n  );\n\n  const reset: ResetFunction = React.useCallback(() => {\n    setQueryRef(null);\n  }, [queryRef]);\n\n  return [loadQuery, queryRef, { fetchMore, refetch, reset }];\n}\n", "import * as React from \"rehackt\";\nimport {\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryReference } from \"../internal/index.js\";\nimport type { OperationVariables } from \"../../core/types.js\";\nimport type { RefetchFunction, FetchMoreFunction } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreQueryOptions } from \"../../core/watchQueryOptions.js\";\n\nexport interface UseQueryRefHandlersResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryReference` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryReference<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return { refetch, fetchMore };\n}\n", "import * as React from \"rehackt\";\nimport {\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryReference } from \"../internal/index.js\";\nimport { __use, wrapHook } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { ApolloError } from \"../../errors/index.js\";\nimport type { NetworkStatus } from \"../../core/index.js\";\n\nexport interface UseReadQueryResult<TData = unknown> {\n  /**\n   * An object containing the result of your GraphQL query after it completes.\n   *\n   * This value might be `undefined` if a query results in one or more errors\n   * (depending on the query's `errorPolicy`).\n   */\n  data: TData;\n  /**\n   * If the query produces one or more errors, this object contains either an\n   * array of `graphQLErrors` or a single `networkError`. Otherwise, this value\n   * is `undefined`.\n   *\n   * This property can be ignored when using the default `errorPolicy` or an\n   * `errorPolicy` of `none`. The hook will throw the error instead of setting\n   * this property.\n   */\n  error: ApolloError | undefined;\n  /**\n   * A number indicating the current network state of the query's associated\n   * request. {@link https://github.com/apollographql/apollo-client/blob/d96f4578f89b933c281bb775a39503f6cdb59ee8/src/core/networkStatus.ts#L4 | See possible values}.\n   */\n  networkStatus: NetworkStatus;\n}\n\nexport function useReadQuery<TData>(\n  queryRef: QueryReference<TData>\n): UseReadQueryResult<TData> {\n  return wrapHook(\n    \"useReadQuery\",\n    _useReadQuery,\n    unwrapQueryRef(queryRef)[\"observable\"]\n  )(queryRef);\n}\n\nfunction _useReadQuery<TData>(\n  queryRef: QueryReference<TData>\n): UseReadQueryResult<TData> {\n  const internalQueryRef = React.useMemo(\n    () => unwrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  const getPromise = React.useCallback(\n    () => getWrappedPromise(queryRef),\n    [queryRef]\n  );\n\n  if (internalQueryRef.disposed) {\n    internalQueryRef.reinitialize();\n    updateWrappedQueryRef(queryRef, internalQueryRef.promise);\n  }\n\n  React.useEffect(() => internalQueryRef.retain(), [internalQueryRef]);\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          updateWrappedQueryRef(queryRef, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef]\n    ),\n    getPromise,\n    getPromise\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n", "import type {\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport type {\n  DeepPartial,\n  OnlyRequiredProperties,\n} from \"../../utilities/index.js\";\nimport { InternalQueryReference, wrapQueryRef } from \"../internal/index.js\";\nimport type { QueryReference } from \"../internal/index.js\";\nimport type { NoInfer } from \"../index.js\";\n\ntype VariablesOption<TVariables extends OperationVariables> =\n  [TVariables] extends [never] ?\n    {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n      variables?: Record<string, never>;\n    }\n  : {} extends OnlyRequiredProperties<TVariables> ?\n    {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n      variables?: TVariables;\n    }\n  : {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#variables:member} */\n      variables: TVariables;\n    };\n\nexport type PreloadQueryFetchPolicy = Extract<\n  WatchQueryFetchPolicy,\n  \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n>;\n\nexport type PreloadQueryOptions<\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#canonizeResults:member} */\n  canonizeResults?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n  context?: DefaultContext;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n  errorPolicy?: ErrorPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n  fetchPolicy?: PreloadQueryFetchPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n  returnPartialData?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n  refetchWritePolicy?: RefetchWritePolicy;\n} & VariablesOption<TVariables>;\n\ntype PreloadQueryOptionsArg<\n  TVariables extends OperationVariables,\n  TOptions = unknown,\n> = [TVariables] extends [never] ?\n  [options?: PreloadQueryOptions<never> & TOptions]\n: {} extends OnlyRequiredProperties<TVariables> ?\n  [\n    options?: PreloadQueryOptions<NoInfer<TVariables>> &\n      Omit<TOptions, \"variables\">,\n  ]\n: [\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      Omit<TOptions, \"variables\">,\n  ];\n\n/**\n * A function that will begin loading a query when called. It's result can be\n * read by `useReadQuery` which will suspend until the query is loaded.\n * This is useful when you want to start loading a query as early as possible\n * outside of a React component.\n *\n * @example\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * const queryRef = preloadQuery(query, { variables, ...otherOptions });\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<div>Loading</div>}>\n *       <MyQuery />\n *     </Suspense>\n *   );\n * }\n *\n * function MyQuery() {\n *   const { data } = useReadQuery(queryRef);\n *\n *   // do something with `data`\n * }\n * ```\n */\nexport interface PreloadQueryFunction {\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <\n    TData,\n    TVariables extends OperationVariables,\n    TOptions extends Omit<PreloadQueryOptions, \"variables\">,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: PreloadQueryOptionsArg<NoInfer<TVariables>, TOptions>\n  ): QueryReference<\n    TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n      TOptions[\"returnPartialData\"] extends true ?\n        DeepPartial<TData> | undefined\n      : TData | undefined\n    : TOptions[\"returnPartialData\"] extends true ? DeepPartial<TData>\n    : TData,\n    TVariables\n  >;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): QueryReference<DeepPartial<TData> | undefined, TVariables>;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): QueryReference<TData | undefined, TVariables>;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n    }\n  ): QueryReference<DeepPartial<TData>, TVariables>;\n\n  /** {@inheritDoc @apollo/client!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: PreloadQueryOptionsArg<NoInfer<TVariables>>\n  ): QueryReference<TData, TVariables>;\n}\n\n/**\n * A higher order function that returns a `preloadQuery` function which\n * can be used to begin loading a query with the given `client`. This is useful\n * when you want to start loading a query as early as possible outside of a\n * React component.\n *\n * > Refer to the [Suspense - Initiating queries outside React](https://www.apollographql.com/docs/react/data/suspense#initiating-queries-outside-react) section for a more in-depth overview.\n *\n * @param client - The `ApolloClient` instance that will be used to load queries\n * from the returned `preloadQuery` function.\n * @returns The `preloadQuery` function.\n *\n * @example\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * ```\n * @since 3.9.0\n * @alpha\n */\nexport function createQueryPreloader(\n  client: ApolloClient<any>\n): PreloadQueryFunction {\n  return function preloadQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      VariablesOption<TVariables> = Object.create(null)\n  ): QueryReference<TData, TVariables> {\n    const queryRef = new InternalQueryReference(\n      client.watchQuery({\n        ...options,\n        query,\n      } as WatchQueryOptions<any, any>),\n      {\n        autoDisposeTimeoutMs:\n          client.defaultOptions.react?.suspense?.autoDisposeTimeoutMs,\n      }\n    );\n\n    return wrapQueryRef(queryRef);\n  };\n}\n"],
  "mappings": "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",
  "names": ["React", "React", "React", "React", "DocumentType", "React", "React", "React", "React", "React", "realHook", "__use", "InternalState", "result", "eagerMethods", "key", "execute", "options", "React", "execute", "_a", "options", "mutation", "client", "React", "_a", "_b", "subscription", "result", "React", "React", "cache", "from", "React", "InternalQueryReference", "SuspenseCache", "promise", "options", "variables", "_a", "React", "options", "promise", "variables", "React", "options", "promise", "queryRef", "React", "React", "promise"]
}
